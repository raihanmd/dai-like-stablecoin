/**
 * Script untuk generate TypeScript ABI definitions dari Foundry deployments
 *
 * Cara pakai:
 * 1. Install dependencies: npm install prettier
 * 2. Jalankan: npx tsx generateTsAbis.ts
 * atau bisa juga: node --loader ts-node/esm generateTsAbis.ts
 */

import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";

const generatedContractComment = `
/**
 * This file is autogenerated from Foundry deployments.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const BROADCAST_DIR = "../contracts/broadcast";
const OUT_DIR = "../contracts/out";
const TARGET_DIR = "./_generated-abi/";

interface ContractData {
  address: string;
  abi: any[];
  inheritedFunctions?: Record<string, string>;
}

interface ChainContracts {
  [contractName: string]: ContractData;
}

interface AllContractsData {
  [chainId: string]: ChainContracts;
}

/**
 * Get all deployment script folders from broadcast directory
 */
function getDeploymentScripts(broadcastPath: string): string[] {
  if (!fs.existsSync(broadcastPath)) {
    throw new Error("Please deploy contracts first using Foundry.");
  }
  return fs
    .readdirSync(broadcastPath, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);
}

/**
 * Get chain folders from a deployment script
 */
function getChainFolders(scriptPath: string): string[] {
  if (!fs.existsSync(scriptPath)) {
    return [];
  }
  return fs
    .readdirSync(scriptPath, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);
}

/**
 * Parse run-latest.json dari broadcast folder untuk dapat deployed contracts
 */
function parseDeploymentFile(filePath: string): any[] {
  try {
    const content = JSON.parse(fs.readFileSync(filePath, "utf-8"));
    return content.transactions || [];
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}`);
    return [];
  }
}

/**
 * Get ABI from Foundry's out directory
 */
function getAbiFromOut(contractName: string): any[] | null {
  const contractPath = path.join(
    OUT_DIR,
    `${contractName}.sol`,
    `${contractName}.json`,
  );

  if (fs.existsSync(contractPath)) {
    try {
      const contractJson = JSON.parse(fs.readFileSync(contractPath, "utf-8"));
      return contractJson.abi || [];
    } catch (error) {
      console.warn(`Warning: Could not read ABI for ${contractName}`);
      return null;
    }
  }

  return null;
}

/**
 * Get inherited functions from contract metadata
 */
function getInheritedFunctions(contractName: string): Record<string, string> {
  const contractPath = path.join(
    OUT_DIR,
    `${contractName}.sol`,
    `${contractName}.json`,
  );
  const inheritedFunctions: Record<string, string> = {};

  if (!fs.existsSync(contractPath)) {
    return inheritedFunctions;
  }

  try {
    const contractJson = JSON.parse(fs.readFileSync(contractPath, "utf-8"));
    const metadata = contractJson.metadata
      ? JSON.parse(contractJson.metadata)
      : null;

    if (!metadata?.settings?.compilationTarget) {
      return inheritedFunctions;
    }

    // Parse untuk cari inherited contracts
    const sources = metadata.sources || {};
    for (const [sourcePath, sourceData] of Object.entries(sources)) {
      const sourceContent = (sourceData as any).content;
      if (sourceContent && typeof sourceContent === "string") {
        // Regex untuk cari inherited contracts
        const regex = /contract\s+\w+\s+is\s+([^{]+)\{/g;
        const matches = sourceContent.matchAll(regex);

        for (const match of matches) {
          const inheritancePart = match[1];
          const inheritedContracts = inheritancePart!
            .split(",")
            .map((c) => c.trim())
            .filter((c) => c.length > 0);

          for (const inherited of inheritedContracts) {
            inheritedFunctions[inherited] = sourcePath;
          }
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not parse metadata for ${contractName}`);
  }

  return inheritedFunctions;
}

/**
 * Main function untuk extract contract data dari Foundry deployments
 */
function getContractDataFromFoundry(): AllContractsData {
  if (!fs.existsSync(BROADCAST_DIR)) {
    throw new Error(
      "Broadcast directory not found. Make sure you have deployed contracts using Foundry.",
    );
  }

  const allContractsData: AllContractsData = {};
  const deploymentScripts = getDeploymentScripts(BROADCAST_DIR);

  for (const scriptName of deploymentScripts) {
    const scriptPath = path.join(BROADCAST_DIR, scriptName);
    const chainFolders = getChainFolders(scriptPath);

    for (const chainId of chainFolders) {
      const runLatestPath = path.join(scriptPath, chainId, "run-latest.json");

      if (!fs.existsSync(runLatestPath)) {
        continue;
      }

      const transactions = parseDeploymentFile(runLatestPath);

      // Initialize chain data jika belum ada
      if (!allContractsData[chainId]) {
        allContractsData[chainId] = {};
      }

      // Extract deployed contracts dari transactions
      for (const tx of transactions) {
        if (
          tx.transactionType === "CREATE" &&
          tx.contractName &&
          tx.contractAddress
        ) {
          const contractName = tx.contractName;
          const contractAddress = tx.contractAddress;

          // Get ABI
          const abi = getAbiFromOut(contractName);

          if (abi) {
            // Get inherited functions
            const inheritedFunctions = getInheritedFunctions(contractName);

            allContractsData[chainId][contractName] = {
              address: contractAddress,
              abi: abi,
              inheritedFunctions: inheritedFunctions,
            };

            console.log(
              `‚úÖ Found ${contractName} on chain ${chainId} at ${contractAddress}`,
            );
          }
        }
      }
    }
  }

  return allContractsData;
}

/**
 * Generate TypeScript file dengan contract definitions
 */
async function generateTsAbis() {
  console.log("üîç Scanning Foundry deployments...");

  const allContractsData = getContractDataFromFoundry();

  if (Object.keys(allContractsData).length === 0) {
    console.warn("‚ö†Ô∏è  No contracts found in broadcast directory");
    return;
  }

  const fileContent = Object.entries(allContractsData).reduce(
    (content, [chainId, chainConfig]) => {
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
    },
    "",
  );

  // Create target directory jika belum ada
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  const formattedContent = await prettier.format(
    `${generatedContractComment}
    
const deployedContracts = {${fileContent}} as const;

export default deployedContracts;`,
    {
      parser: "typescript",
    },
  );

  fs.writeFileSync(
    path.join(TARGET_DIR, "deployedContracts.ts"),
    formattedContent,
  );

  console.log(
    `üìù Generated TypeScript contract definitions at ${TARGET_DIR}deployedContracts.ts`,
  );
  console.log(
    `‚ú® Done! Found contracts on ${Object.keys(allContractsData).length} chain(s)`,
  );
}

// Run the script
generateTsAbis().catch(console.error);
